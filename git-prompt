#!/usr/bin/env bash

# Color codes.
Color_Off="\[\033[0m\]"

# Regular colors
Black="\[\033[0;35m\]"
Red="\[\033[0;31m\]"
Green="\[\033[0;32m\]"
Yellow="\[\033[0;33m\]"
Blue="\[\033[0;34m\]"
Purple="\[\033[0;35m\]"
Cyan="\[\033[0;36m\]"
White="\[\033[0;37m\]"

# Bold colors
BBlack="\[\033[1;35m\]"
BRed="\[\033[1;31m\]"
BGreen="\[\033[1;32m\]"
BYellow="\[\033[1;33m\]"
BBlue="\[\033[1;34m\]"
BPurple="\[\033[1;35m\]"
BCyan="\[\033[1;36m\]"
BWhite="\[\033[1;37m\]"

# Color parameters
User_color=${BGreen}
At_color=${Purple}
Host_color=${BBlue}
Path_color=${BPurple}

Branch_color=${Green}
Ahead_color=${Green}
Behind_color=${Red}
NoSync_color=${Red}
Fetch_color="\033[0;32m"
Git_color=${White}
Prompt_color=${White}
Prompt_error_color=${BRed}

# Prompt parameters
Force_Normal_Prompt=0

# Append __git_prompt() to prompt commands
GIT_INSTALLED="$(which git)"
if [[ $GIT_INSTALLED ]]; then
    if [[ $PROMPT_COMMAND == "" ]]; then
	if [[ $PS1 == "" || $Force_Normal_Prompt == 1 ]]; then
	    export PROMPT_COMMAND="__normal_prompt;__git_prompt"
	else
	    NORMAL_PS1=${PS1}
	    export PROMPT_COMMAND="__git_prompt"
	fi
    elif ! [[ $PROMPT_COMMAND =~ git_prompt ]]; then
	export PROMPT_COMMAND="$PROMPT_COMMAND;__git_prompt"
    fi
fi

# Default parameters
GIT_PROMPT=1
GIT_AUTOFETCH=1
GIT_AUTOFETCH_INTERVAL=600

# Status variables
GIT_LAST_ROOT=""
GIT_LAST_BRANCH=""
GIT_LAST_FETCH=$(date '+%s')

__git_prompt() {
    local EXIT="$?"

    if [[ $GIT_PROMPT != 0 ]]; then

	local GIT_BRANCH_STATUS="$(git status -bs 2>&1 | head -1)"

	if ! [[ "$GIT_BRANCH_STATUS" =~ fatal ]]; then
	    PS1=""
	    # Get branch name and upstream (if any).
	    if [[ "$GIT_BRANCH_STATUS" =~ \#\#\ ([^\ ]+)\.\.\.([^\ ]+) ]]; then
		GIT_BRANCH=${BASH_REMATCH[1]}
		GIT_UPSTREAM=${BASH_REMATCH[2]}
	    elif [[ "$GIT_BRANCH_STATUS" =~ \#\#\ ([^\ ]+) ]]; then
		GIT_BRANCH=${BASH_REMATCH[1]}
		GIT_UPSTREAM=""
	    fi

	    local GIT_ROOT="$(git rev-parse --show-toplevel)"

	    local AUTOFETCH=0
	    # Trigger autofecth when changing repository.
	    if [[ $GIT_LAST_ROOT != $GIT_ROOT ]]; then
		AUTOFETCH=1
		GIT_LAST_ROOT=$GIT_ROOT
	    fi

	    # Trigger autofecth when changing branch.
	    if [[ $GIT_LAST_BRANCH != $GIT_BRANCH ]]; then
		AUTOFETCH=1
		GIT_LAST_BRANCH=$GIT_BRANCH
	    fi


	    # Sync only if there is an upstream branch defined.
	    if [[ $GIT_UPSTREAM != "" ]]; then

		# Trigger autofetch every GIT_AUTOFETCH_INTERVAL since last fetch/pull.
		if [[ $AUTOFETCH == 0 ]]; then

		    # Get last fetch time from last_modified(.git/FETCH_HEAD)
		    local LAST_FETCH_OUT="$(stat -c \"%Y %s\" $GIT_ROOT/.git/FETCH_HEAD 2>&1)"
		    if [[ "$LAST_FETCH_OUT" =~ ^([0-9]+)\ ([0-9]+)$ ]]; then
			# File size is 0 If last fetch did not work (probably offline).
			if [[ ${BASH_REMATCH[2]} != "0" ]]; then
			    GIT_LAST_FETCH=${BASH_REMATCH[1]}
			    GIT_ONLINE=1
			else
			    GIT_ONLINE=0
			fi
		    fi

		    # Compare it with current time
		    local CUR_TIME=$(date '+%s')
		    if [[ $GIT_LAST_FETCH == "" ]] || [[ $(($CUR_TIME - $GIT_LAST_FETCH)) -gt $GIT_AUTOFETCH_INTERVAL ]]; then
			AUTOFETCH=1
		    fi
		fi
		
		# Autofetch.
		if [[ $AUTOFETCH == 1 ]]; then
		    # Notify in prompt.
		    printf "${Fetch_color}${GIT_BRANCH}:fetch...\033[0m"
		    # Fetch changes in current branch.
		    FETCH_INFO="$(git fetch origin $GIT_BRANCH 2>&1)";
		    if [[ "$FETCH_INFO" =~ fatal ]]; then
			GIT_ONLINE=0
		    else
			GIT_ONLINE=1
		    fi
		    # This avoids constant retries when offline.
		    GIT_LAST_FETCH=$(date '+%s')
		    # Overwrite line with full prompt.
		    printf "\r"
		fi


		# Create status string.
		GIT_STATUS_STRING=""

		# Get commits ahead/behind relative to upstream.
		local GIT_NEWSTATUS="$(git rev-list --left-right --count ${GIT_BRANCH}...${GIT_UPSTREAM} 2>&1)"

		# Check whether info is available.
		local SYNC_INFO_AVAILABLE=1
		if [[ "$GIT_NEWSTATUS" =~ fatal ]]; then
		    SYNC_INFO_AVAILABLE=0
		fi

		# If not available or not connected, show broken connection symbol.
		if [[ $SYNC_INFO_AVAILABLE == 0 ]] || [ $GIT_ONLINE == 0 ]; then
		    GIT_STATUS_STRING+="${At_color}(${Color_off}${NoSync_color}҂${Color_Off}${At_color})${Color_Off}"
		fi

		# Add upstream sync info to prompt.
		if [[ $SYNC_INFO_AVAILABLE == 1 ]]; then
		    local GIT_AHEAD=""
		    local GIT_BEHIND=""
		    if [[ "$GIT_NEWSTATUS" =~ ^([0-9]+) ]]; then
			if [[ "${BASH_REMATCH[1]}" != "0" ]]; then
			    GIT_AHEAD="${Ahead_color}${BASH_REMATCH[1]}↑${Color_Off}"
			fi
		    fi
		    if [[ "$GIT_NEWSTATUS" =~ ([0-9]+)$ ]]; then
			if [[ "${BASH_REMATCH[1]}" != "0" ]]; then
			    GIT_BEHIND="${Behind_color}${BASH_REMATCH[1]}↓${Color_Off}"
			fi
		    fi

		    if [ "$GIT_AHEAD" != "" ]  && [ "$GIT_BEHIND" != "" ]; then
			GIT_STATUS_STRING+="${At_color}(${Color_off}"${GIT_AHEAD}" "${GIT_BEHIND}"${At_color})${Color_Off}"
		    elif [ "$GIT_AHEAD" != "" ]; then
			GIT_STATUS_STRING+="${At_color}(${Color_off}"${GIT_AHEAD}"${At_color})${Color_Off}"
		    elif [ "$GIT_BEHIND" != "" ]; then
			GIT_STATUS_STRING+="${At_color}(${Color_off}"${GIT_BEHIND}"${At_color})${Color_Off}"
		    fi
		fi
	    fi

	    # Get path relative to repository root
	    if [[ "$GIT_ROOT" =~ .*/([^/]+)$ ]]; then
		local GIT_REPO_NAME=${BASH_REMATCH[1]}
	    fi
	    GIT_PATH=$GIT_REPO_NAME
	    if [[ ${PWD} =~ ${GIT_ROOT}(.*$) ]]; then
		GIT_PATH+=${BASH_REMATCH[1]}
	    fi

	    # Prompt git branch.
	    PS1+="${Branch_color}$GIT_BRANCH${Color_Off}"

	    # Prompt sync status.
	    if [[ $GIT_UPSTREAM != "" ]]; then
		PS1+="${GIT_STATUS_STRING}"
	    else
		PS1+="${At_color}(local)${Color_Off}"
	    fi
	    
	    # Prompt host and git repository path.
	    PS1+="${At_color}@${Color_Off}${Host_color}\h${Color_Off}${Git_color}:g~${Color_Off}${Path_color}${GIT_PATH}${Color_Off}"

	    if [ $EXIT != 0 ]; then
		PS1+="${Prompt_error_color}\$${Color_Off} "
	    else
		PS1+="${Prompt_color}\$${Color_Off} "
	    fi
	elif [[ ${PROMPT_COMMAND} == "__git_prompt" ]]; then
	    PS1=${NORMAL_PS1}
	fi
    elif [[ ${PROMPT_COMMAND} == "__git_prompt" ]]; then
	PS1=${NORMAL_PS1}
    fi

}

__normal_prompt() {
    local EXIT="$?"
    
    PS1="${User_color}\u${At_color}@${Host_color}\h${Colon_color}:${Path_color}\w${Color_Off}"
    
    if [[ $EXIT != 0 ]]; then
	PS1+="${Prompt_error_color}\$${Color_Off}"
    else
	PS1+="${Prompt_color}\$${Color_Off}"
    fi
}
